unit Unit1;

{$mode ObjFPC}

interface

uses
  Classes, SysUtils;

type
 // базовый тип элемента данных в хранилище
 TData=pointer;

 // абстрактный класс с описанием механизма доступа к данным
 { TAbstractStorage }

 TAbstractStorage=class
    protected
	function getData(position:qword):TData;virtual;abstract;
	procedure setData(position:qword; value:TData);virtual;abstract;
	function getCount:qword;virtual;abstract;
    protected
	property data[position:qword]:TData read getData write setData; default;
	property count:qword read getcount;
 end;

 // класс с реализацией хранилища в оперативной памяти
 // с автоматическим расширением хранилища при попытке сохранения
 // данных за его пределами и возвратом нулевого значения
 // при попытке чтения данных за его пределами.
 { TMemStorage }

 TMemStorage=class(TAbstractStorage)
    private
	fdata:array of TData;
    protected
	function getData(position:qword):TData;override;
	procedure setData(position:qword; value:TData);override;
    public
        function getCount:qword;override;
 end;

 // класс с реализацией хранилища целочисленных данных в оперативной памяти
 // с преобразованием типа данных integer в TData и обратно.
 { TIntMemStorage }

 TIntMemStorage=class(TMemStorage)
    protected
	function getIData(position:qword):integer;
	procedure setIData(position:qword; value:integer);
    public
	property dataI[position:qword]:integer read getIData write setIData; default;
    end;

 // класс с реализацией хранилища вещественных данных максимальной емкости в оперативной памяти
 // с выделением из оперативной памяти требуемого объема при первом сохранении элемента
 // по каждому индексу и освобождением выделенной памяти деструктором.
 // Преобразование TData <-> extended по аналогии с классом TIntMemStorage невозможно,
 // так как размер типа extended превышает размер типа TData.
 { TFloatMemStorage }

 TFloatMemStorage=class(TMemStorage)
    protected
	function getfData(position:qword):extended;
	procedure setfData(position:qword; value:extended);
    public
	property dataF[position:qword]:extended read getfData write setfData; default;
	destructor Destroy;override;
    end;

implementation

{ TMemStorage }

function TMemStorage.getData(position: qword): TData;
begin
  if (position >= Length(fdata)) then exit(nil);
  result := fdata[position];
end;

procedure TMemStorage.setData(position: qword; value: TData);
begin
  if (position >= Length(fdata)) then SetLength(fdata, position+1);
  fdata[position] := value;
end;

function TMemStorage.getCount: qword;
begin
    result := Length(fdata);
end;

{ TIntMemStorage }

function TIntMemStorage.getIData(position: qword): integer;
begin
  result := integer(getData(position));
end;

procedure TIntMemStorage.setIData(position: qword; value: integer);
begin
   setData(position, pointer(value));
end;

{ TFloatMemStorage }

function TFloatMemStorage.getfData(position: qword): extended;
var p: ^extended;
begin
  p := getData(position);
  if (p = nil) then exit(0.0);
  result := extended(p^);
end;

procedure TFloatMemStorage.setfData(position: qword; value: extended);
var p: ^extended;
begin
  if (getData(position) = nil) then
  begin
    p := getmem(sizeof(extended));
    data[position] := p;
  end;
  p := data[position];
  p^ := value;
end;

destructor TFloatMemStorage.Destroy;
var i:integer;
begin
  for i:= 0 to Length(fdata) do
  begin
    if (data[i] = nil) then break;
    freemem(data[i]);
  end;
end;

end.

